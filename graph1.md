#I-3. Complexity
---

##$$$\Theta$$$-표기 


$$$\Theta (g(n))$$$ = { f(n) : 모든 n >= $$${ n }_{ 0 }$$$ 에 대해 
	
0 <= c1g(n) <= f(n) <= c2g(n)인 양의정수 c1,c2,n0가 존재한다.

$$$
 	O(g(n))$$$ : 함수의 상한을 나타낸다(빅오).
 	
 $$$
 \Omega (g(n)) : 함수의 하한을 나타낸다.
$$$

 $$$
 o (g(n)) : 리틀오 .
$$$
 
 
 
--- 
 
#III. Graph Algorithm
##* 개요 
	그래프 문제는 컴퓨터과학에서 많이 사용되고, 그래프를 조작하는 알고리즘은 이 분야에서 중요하다. 또한 수많은 흥미로운 문제가 그래프를 이용해 표현할 수 있다. 여기서는 좀 더 중요한 것들 중 일부를 살펴볼 것이다.
	여기서는 
	1. 그래프를 표현하는 방법
	2. 검색 알고리즘 : DFS , LFS
	3. DFS의 응용 : 비순환 방향 그래프의 위상정렬, 방향 그래프를 강한 결합요소로 분해 
	4. 최소 가중치 신장 트리 : 가중치가 있는 그래프에서, 가중치가 가장 작게 모든 노드를 연결하는 방법
		-> 그리디 알고리즘의 좋은 예 
	5. 최단경로
	6. 최대 플로우 계산 
---
##* 기본 그래프 알고리즘
###그래프의 표현
	1.인접 리스트 :  |E| 가 |V|^2에 비해 훨씬 작은 경우 : 낮은 밀도
	2.인접 행렬 : 거의 비슷한 경우 : 높은 밀도 
	
인접 리스트의 경우 필요한 메모리의 양이 $$$\Theta (V + E)$$$ !!!

인접 행렬의 경우 필요한 메모리의 양이 $$$\Theta ({ V }^{ 2 })$$$


###* BFS
>BFS의 경우 가장 단순한 그래프 검색 알고리즘 중 하나로, 중요한 그래프 알고리즘들의 원형이다.
	Prim의 최소 신장 트리 알고리즘과 다익스트라(Dijkstra)의 단일 출발점 최단경로 알고리즘은 
	BFS와 비슷한 아이디어를 사용한다. 


BFS(G,s)

1. for 각각의 정점 u $$$\in $$$ G.V - {s}
2. 	....u.color = WHITE
3. 	....u.d = INFINITE
4. 	....u.$$$\pi$$$ = NIL
5. 	s.color = GRAY
6. 	s.d = 0
7. 	s.$$$\pi$$$  = NIL
8. 	Q = $$$\phi$$$
9. 	Enque(Q,s)
10. while Q != $$$\phi$$$
11.    u = Deque(Q)
12. ....for 각각의 v $$$\in$$$G.Adj[u]
13. ......if(v.color == WHITE)
14. ........v.color = GRAY
15. ........v.d = u.d + 1
16. ........v.$$$\pi$$$ = u
17. ........ENQUEUE(Q,v)
18. ..../u.color = BLACK 


	>프로시저 BFS는 다음과 같이 수행된다. 출발점 s를 제외하고 모든 정점을 흰색으로 칠하고 각 정점 u에 대해 u.d를 무한대의 값으로 설정하며, 각 정점의 부모정점을 NIL로 만든다. 5행은 s를 회색으로 만드는데 이는 프로시저가 처음 시작할 때 이미 s는 발견된 것으로 간주하기 때문이다. 6행은 s.d를 9으로 초기화하고 7행은 출발점 s의 직전원소를 NIL로 만든다.
	8-9행은 Q를 정점 s만 포함하고 있는 큐로 초기화한다.10-18행의 while루프는 회색 정점이 남아 있는 동안 반복되는데, 여기서 회색 정점은 발견은 되었지만 아직 인접 리스트가 완전히 조사되지 않은 정점이다. 이 while루프는 다음과 같은 불변식을 유지한다.
	"10행의 검사에서 큐 Q는 회색 정점으로 구성된다"
	
-> BFS의 경우 인접 리스트를 사용했을때 O(V + E) 의 수행시간이 걸린다. 즉 그래프 G의 인접 리스트 표현의 크기에 선형적으로 비례하는 시간이 걸린다.

###* DFS
>DFS는 가장 최근에 발견되고 아직 조사하지 않은 간선을 가진 정점 v로 부터 나오는 간선을 조사한다. v의 모든 간선이 조사되면 그 검색은 v를 발견하게 해준 정점으로부터 나오는 간선을 조사하기 위해 "뒤로 되돌아간다". 이 과정은 원래의 출발점으로부터 도달할 수 있는 모든 정점이 발견될 때까지 계속된다. 발견되지 않은 정점이 하나라도 남아 있으면, 깊이 우선 검색은 그 중 하나를 새 출발점으로 선택하고 해당 출발점으로부터의 검색을 반복한다. 
	
DFS(G)

1. for 각 정점 u $$$\in$$$ G.V

2. ....u.color = WHITE

3. ....u.$$$\pi$$$ = NIL
4. time = 0
5. for 각 정점 u $$$\in$$$ G.V
6. ....if(u.color == WHITE)
7. ........DFS_VISIT(G,u)

DFS-VISIT(G, u)

1. time = time + 1 //  흰색 정점 u가 막 발견되었다

2. u.d = time
3. u.color = GRAY
4. for 각각의 v $$$\in$$$ G.Adj[u] // 간선 (u,v)를 탐색한다
5. ....if(v.color == WHITE)
6. ........v.$$$\pi$$$ = u
7. ........DFS-VISIT(G, v)
8. u.color = BLACK // u를 검은색으로 칠한다. 종료되었다.
9. time = time+1
10. u.f = time

->DFS의 수행시간은 O(V + E)이다.

---

###* 위상정렬(그래프 순환이 존재하지 않아야 한다!!!)- DFS 활용 1
	: 깊이 우선 검색을 이용해 방향 비순환 그래프의 위상 정렬을 수행하는 방법을 본다.
	위상 정렬 : (Topological sort) G가 간선(u,v)를 가질 때 u가 v보다 순서상으로 먼저 나타나도록 모든 정점을 선형으로 나열하는 것
	ex) 대학 선수과목 문제
	
TOPOLOGICAL-SORT(G)

1. 각 정점 v에 대해 종료시간 v.f를 계산하기 위해 DFS(G)를 호출한다.
2. 각 정점이 종료될 때마다 연결리스트의 맨 앞에 삽입한다.
3. return 정점의 연결리스트

방법2
버텍스로 들어오는 차수가 0인놈의 선택과 그에 붙어있는 간선을 삭제과정을 반복하여 모든 정점이 선택/삭제되면 알고리즘을 종료한다.

-> 위상정렬의 수행시간은 O(V + E)이다.

---

###* 강한 연결요소 ((u, v) , (v,u) 둘다 존재) - DFS 활용 2

1. 각 정점 u에 대해 종료시간 f(u)를 계산하기 위해 DFS(G)를 호출한다.
2. 전치행렬 G(T)를 계산한다.
3. DFS(G(T))를 호출한다. f(u)가 가장 높은 정점부터 시작한다.
	f(u)가 가장 높다는 것은 DFS(G)의 계산 결과 얻어진 종료된 정점들을 스택에 넣어서 꺼낸다는 말과 같다.
	
	
---

#* 최소신장트리
> A,B,C 3개의 섬으로 이루어진 나라가 있어. 정부는 국민들이 섬에서 섬으로 편리하게 오고 가고 싶어하는데, 이 나라는 지독히도 가난해서 모든 섬을 이을 예산은 없대.. 어떻게 가장 돈을 적게 들여 모든 섬을 연결할 수 있을까???

## 2개의 알고리즘(Greedy)
1. 크루스칼
2. 프림 


	-> 두 알고리즘은 일반적인 이진 힙을 사용하면 O(ElgV )시간에 실행될 수 있다.
	
	-> 피보나치 힙을 사용한 경우 O(E + VlgV)시간에 실행될 수 있다.
	
MST-KRUSKAL(G,w)

1. A = $$$\phi$$$
2. for 각각의 정점 v $$$\in$$$ G.V
3. ....MAKE-SET(v)
4. E의 간선을 가중치 w에 따라 감소하지 않는 순서로 정렬한다.
5. for 가중치에 대해 감소하지 않는 순서에 의한 각 간산(u,v) $$$\in$$$ G.E
6. ....if FIND_SET(u) != FIND_SET(v)
7. ........A = A$$$\sqcup$$${(u,v)}
8. ........UNION(u,v)
9. return A


    1-3행 : 집합 A를 공집합으로 초기화 하고 V개의 트리를 생성
    
    5-8행 : for룹은 간선을 가중치가 증가하는 순서로 조사 두 버텍스가 같은 트리에 속하지 않으면 합침
    
MST-PRIM(G, w, r)

1. for 각각의 u $$$\in$$$ G.V
2. ....u.key = INF
3. ....u.$$$\pi$$$ = NIL
4. r.key = 0
5. Q = G.V
6. while Q != $$$\phi$$$
7. ....u = EXTRACT-MIN(Q)
8. ....for 각 v $$$\in$$$ G.Adj[u]
9. ........if v $$$\in$$$Q && w(u,v) < v.key
10. ..........v.$$$\pi$$$ = u
11. ..........v.key = w(u,v)

    1-5행 : 각 정점의 키를 INFINITE로 설정(루트의 경우는 예외, 루트의 키는 0으로 설정해 처음으로 처리될 정점이 되도록 한다
    
   -> 프림 알고리즘의 수행시간은 최소 우선순위 큐 Q의 구현에 따라 달라진다.
 
   